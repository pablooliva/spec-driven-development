#!/usr/bin/env python3
"""
Automatic Subagent Call Logger for Spec-Driven Development
Captures subagent calls with context and saves to permanent logs
"""

import json
import os
import sys
import tempfile
from datetime import datetime
from pathlib import Path
from typing import Any

# Constants
DEFAULT_TRANSCRIPT_LINES = 50
MAX_LINE_LENGTH = 10000  # Prevent memory issues with extremely long lines
LOG_SUBDIR = Path("SDD") / "prompts" / "context-management" / "subagent-calls"


def load_hook_input() -> dict[str, Any]:
    """Load the hook input data from stdin"""
    try:
        return json.load(sys.stdin)
    except json.JSONDecodeError as e:
        print(f"Failed to parse hook input: {e}", file=sys.stderr)
        return {}


def generate_log_filename() -> str:
    """Generate timestamped filename for subagent call log"""
    timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
    return f"subagent-call-{timestamp}.md"


def extract_subagent_context(hook_data: dict[str, Any]) -> dict[str, str]:
    """Extract relevant context from hook data"""
    session_id = hook_data.get("session_id", "unknown")
    transcript_path = hook_data.get("transcript_path", "")
    cwd = hook_data.get("cwd", "")

    return {
        "session_id": session_id,
        "transcript_path": transcript_path,
        "working_directory": cwd,
        "timestamp": datetime.now().isoformat(),
    }


def read_recent_transcript(transcript_path: str, lines: int = DEFAULT_TRANSCRIPT_LINES) -> str:
    """Read the last N lines from the transcript to capture subagent interaction"""
    if not transcript_path:
        return "Transcript path not provided"

    if not os.path.exists(transcript_path):
        return f"Transcript not found at: {transcript_path}"

    try:
        # Read last N lines efficiently without loading entire file
        with open(transcript_path, "rb") as f:
            # Seek to end
            f.seek(0, os.SEEK_END)
            file_size = f.tell()

            # For small files, just read everything
            if file_size < 100000:  # 100KB
                f.seek(0)
                content = f.read().decode("utf-8", errors="replace")
                lines_list = content.splitlines(keepends=True)
                return "".join(lines_list[-lines:])

            # For large files, read from end in chunks
            buffer_size = 8192
            lines_found = []
            position = file_size

            while position > 0 and len(lines_found) < lines:
                chunk_size = min(buffer_size, position)
                position -= chunk_size
                f.seek(position)
                chunk = f.read(chunk_size).decode("utf-8", errors="replace")
                chunk_lines = chunk.splitlines(keepends=True)
                lines_found = chunk_lines + lines_found

            # Truncate very long lines to prevent memory issues
            result_lines = []
            for line in lines_found[-lines:]:
                if len(line) > MAX_LINE_LENGTH:
                    result_lines.append(line[:MAX_LINE_LENGTH] + "... [truncated]\n")
                else:
                    result_lines.append(line)

            return "".join(result_lines)

    except Exception as e:
        return f"Error reading transcript: {str(e)}"


def create_subagent_log_entry(context: dict[str, str], transcript_excerpt: str) -> str:
    """Create the markdown log entry for the subagent call"""
    return f"""# Subagent Call - {context['timestamp']}

## Session Context
- **Session ID**: `{context['session_id']}`
- **Working Directory**: `{context['working_directory']}`
- **Timestamp**: {context['timestamp']}

## Subagent Interaction
*(Last {DEFAULT_TRANSCRIPT_LINES} lines of transcript showing subagent call and response)*

```
{transcript_excerpt}
```

---
*Auto-generated by Claude Code SubagentStop hook*
"""


def save_subagent_log(log_content: str) -> Path:
    """Save the subagent log to the appropriate directory"""
    try:
        # Ensure the subagent-calls directory exists
        project_root = os.environ.get("CLAUDE_PROJECT_DIR")
        if not project_root:
            print("Warning: CLAUDE_PROJECT_DIR not set, using current directory", file=sys.stderr)
            project_root = os.getcwd()

        log_dir = Path(project_root) / LOG_SUBDIR
        log_dir.mkdir(parents=True, exist_ok=True)

        # Generate unique filename atomically using temp file
        filename = generate_log_filename()

        # Use atomic write: write to temp file then rename
        with tempfile.NamedTemporaryFile(
            mode="w",
            dir=log_dir,
            prefix=".tmp_subagent_",
            suffix=".md",
            delete=False,
        ) as tmp_file:
            tmp_file.write(log_content)
            tmp_path = Path(tmp_file.name)

        # Atomic rename
        final_path = log_dir / filename
        counter = 1
        while True:
            try:
                tmp_path.rename(final_path)
                break
            except FileExistsError:
                # File exists, try with counter
                timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
                filename = f"subagent-call-{timestamp}-{counter}.md"
                final_path = log_dir / filename
                counter += 1

        return final_path

    except Exception as e:
        print(f"Error saving subagent log: {e}", file=sys.stderr)
        raise


def main() -> None:
    """Main function to process subagent stop hook"""
    try:
        # Load hook input data
        hook_data = load_hook_input()

        # Validate required fields
        if not hook_data:
            print("Warning: No hook data received", file=sys.stderr)
            return

        # Extract context
        context = extract_subagent_context(hook_data)

        # Read recent transcript to capture subagent interaction
        transcript_excerpt = read_recent_transcript(
            hook_data.get("transcript_path", ""),
            DEFAULT_TRANSCRIPT_LINES
        )

        # Create log entry
        log_content = create_subagent_log_entry(context, transcript_excerpt)

        # Save to file
        log_path = save_subagent_log(log_content)

        # Provide feedback (stderr for debug logs only)
        print(f"Subagent call logged to: {log_path}", file=sys.stderr)

    except Exception as e:
        print(f"Fatal error in subagent hook: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
